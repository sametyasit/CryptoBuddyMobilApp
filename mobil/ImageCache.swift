import Foundation
import UIKit

/// Hem bellek hem de disk √∂nbellekleme yapan geli≈ümi≈ü bir g√∂rsel √∂nbellekleme sistemi
class ImageCache {
    // Singleton √∂rnek
    static let shared = ImageCache()
    
    // Bellek √∂nbelleƒüi
    private let memoryCache = NSCache<NSString, UIImage>()
    
    // Disk √∂nbelleƒüi i√ßin dosya y√∂neticisi
    private let fileManager = FileManager.default
    private let diskCacheFolder = "CoinLogoCache"
    
    // ƒ∞statistik deƒüi≈ükenleri
    private(set) var memoryHits = 0
    private(set) var diskHits = 0
    private(set) var networkHits = 0
    
    // √ñnbellekleme i√ßin zaman a≈üƒ±mƒ± deƒüerleri
    private let memoryCacheTimeoutHours: TimeInterval = 1 // 1 saat
    private let diskCacheTimeoutDays: TimeInterval = 7 // 1 hafta
    
    // Paralel indirme i≈ülemleri i√ßin i≈ülem kuyruƒüu
    private let downloadQueue = DispatchQueue(label: "com.cryptobuddy.imageDownloadQueue", attributes: .concurrent)
    
    // Yeni bir √∂nbellek olu≈üturma
    private init() {
        // Bellek √∂nbelleƒüi yapƒ±landƒ±rmasƒ±
        memoryCache.countLimit = 300 // En fazla 300 g√∂rsel
        memoryCache.totalCostLimit = 50_000_000 // ~50MB bellek sƒ±nƒ±rƒ±
        
        // Uygulama bellek uyarƒ±sƒ± aldƒ±ƒüƒ±nda √∂nbelleƒüi temizleme
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(clearMemoryCache),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
        
        // Disk √∂nbellek klas√∂r√ºn√º olu≈ütur
        createDiskCacheDirectory()
        
        // Eski √∂nbellekleri temizle
        cleanExpiredDiskCache()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    // MARK: - Public Methods
    
    /// Bir g√∂rseli √∂nbellekten alƒ±r veya indirir
    /// - Parameters:
    ///   - url: ƒ∞ndirilecek g√∂rsel URL'si
    ///   - completion: ƒ∞ndirme tamamlandƒ±ƒüƒ±nda √ßaƒürƒ±lacak closure
    func loadImage(from urlString: String, completion: @escaping (UIImage?) -> Void) {
        guard let url = URL(string: urlString) else {
            completion(nil)
            return
        }
        
        let cacheKey = urlString as NSString
        
        // 1. Bellek √∂nbelleƒüinden kontrol et
        if let cachedImage = memoryCache.object(forKey: cacheKey) {
            memoryHits += 1
            completion(cachedImage)
            return
        }
        
        // 2. Disk √∂nbelleƒüinden kontrol et
        if let diskCachedImage = loadImageFromDiskCache(for: cacheKey as String) {
            diskHits += 1
            // Belleƒüe de ekle
            memoryCache.setObject(diskCachedImage, forKey: cacheKey)
            completion(diskCachedImage)
            return
        }
        
        // 3. Aƒüdan indir
        networkHits += 1
        downloadImage(from: url, cacheKey: cacheKey as String) { [weak self] image in
            if let image = image {
                self?.memoryCache.setObject(image, forKey: cacheKey)
                self?.saveImageToDiskCache(image, for: cacheKey as String)
            }
            completion(image)
        }
    }
    
    /// Toplu logo √∂nbelleƒüe alma - Coin listesi g√∂r√ºn√ºm√ºnden √ßaƒürƒ±labilir
    /// - Parameter coins: √ñnbelleƒüe alƒ±nacak coinlerin listesi
    func preloadCoinLogos(for coins: [Coin]) {
        // ƒ∞lk 50 coini √∂nbelleƒüe al - kullanƒ±cƒ± deneyimini iyile≈ütirmek i√ßin
        let topCoins = Array(coins.prefix(50))
        
        // D√º≈ü√ºk √∂ncelikli bir kuyrukta arkaplanda y√ºkle
        DispatchQueue.global(qos: .utility).async { [weak self] in
            guard let self = self else { return }
            
            for coin in topCoins {
                // Logolarƒ± y√ºklerken bir dizi farklƒ± olasƒ± URL'yi dene
                let possibleURLs = [
                    coin.image, // Ana URL
                    "https://assets.coingecko.com/coins/images/\(coin.id)/small/\(coin.symbol).png",
                    "https://s2.coinmarketcap.com/static/img/coins/64x64/\(coin.id).png",
                    "https://raw.githubusercontent.com/spothq/cryptocurrency-icons/master/32/color/\(coin.symbol.lowercased()).png"
                ]
                
                // Her coin i√ßin bir kez ba≈üarƒ±lƒ± olunca diƒüerine ge√ß
                var logoLoaded = false
                
                for urlString in possibleURLs where !logoLoaded {
                    // Bo≈ü veya ge√ßersiz URL'leri atla
                    guard !urlString.isEmpty, let url = URL(string: urlString) else { continue }
                    
                    // √ñnbellek anahtarƒ±
                    let cacheKey = "\(coin.id)_\(coin.symbol)_logo"
                    
                    // Zaten √∂nbellekte var mƒ± kontrol et
                    if self.getImage(forKey: cacheKey) != nil {
                        logoLoaded = true
                        break
                    }
                    
                    // Deƒüilse, indir ve √∂nbelleƒüe al
                    let semaphore = DispatchSemaphore(value: 0)
                    
                    let task = URLSession.shared.dataTask(with: url) { data, response, error in
                        if let data = data, let image = UIImage(data: data) {
                            // Ba≈üarƒ±lƒ± y√ºklemeyi √∂nbelleƒüe kaydet
                            self.setImage(image, forKey: cacheKey)
                            logoLoaded = true
                        }
                        semaphore.signal()
                    }
                    
                    task.resume()
                    
                    // En fazla 2 saniye bekle ve sonraki URL'ye ge√ß
                    _ = semaphore.wait(timeout: .now() + 2)
                    
                    if logoLoaded {
                        break
                    }
                }
            }
            
            print("üì± Logo √∂nbelleƒüe alma tamamlandƒ± - \(topCoins.count) coin i√ßin")
        }
    }
    
    /// Bir g√∂rseli √∂nbelleƒüe alƒ±r
    /// - Parameters:
    ///   - image: √ñnbelleƒüe eklenecek g√∂rsel
    ///   - key: √ñnbellek anahtarƒ±
    func setImage(_ image: UIImage, forKey key: String) {
        let cacheKey = key as NSString
        memoryCache.setObject(image, forKey: cacheKey)
        saveImageToDiskCache(image, for: key)
    }
    
    /// Bir g√∂rseli √∂nbellekten alƒ±r
    /// - Parameter key: √ñnbellek anahtarƒ±
    /// - Returns: √ñnbellekteki g√∂rsel veya nil
    func getImage(forKey key: String) -> UIImage? {
        let cacheKey = key as NSString
        
        // Bellek √∂nbelleƒüinden kontrol
        if let cachedImage = memoryCache.object(forKey: cacheKey) {
            memoryHits += 1
            return cachedImage
        }
        
        // Disk √∂nbelleƒüinden kontrol
        if let diskCachedImage = loadImageFromDiskCache(for: key) {
            diskHits += 1
            // Belleƒüe de ekle
            memoryCache.setObject(diskCachedImage, forKey: cacheKey)
            return diskCachedImage
        }
        
        return nil
    }
    
    /// T√ºm √∂nbelleƒüi temizler
    func clearCache() {
        clearMemoryCache()
        clearDiskCache()
        
        // ƒ∞statistikleri sƒ±fƒ±rla
        memoryHits = 0
        diskHits = 0
        networkHits = 0
    }
    
    // MARK: - Private Methods
    
    @objc private func clearMemoryCache() {
        memoryCache.removeAllObjects()
    }
    
    private func clearDiskCache() {
        do {
            let cacheURL = try diskCacheDirectoryURL()
            let contents = try fileManager.contentsOfDirectory(at: cacheURL, includingPropertiesForKeys: nil)
            for fileURL in contents {
                try fileManager.removeItem(at: fileURL)
            }
        } catch {
            print("Disk √∂nbelleƒüi temizlenirken hata: \(error)")
        }
    }
    
    private func createDiskCacheDirectory() {
        do {
            let cacheURL = try diskCacheDirectoryURL()
            try fileManager.createDirectory(at: cacheURL, withIntermediateDirectories: true)
        } catch {
            print("Disk √∂nbellek klas√∂r√º olu≈üturulurken hata: \(error)")
        }
    }
    
    private func diskCacheDirectoryURL() throws -> URL {
        let cacheDir = try fileManager.url(for: .cachesDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
        return cacheDir.appendingPathComponent(diskCacheFolder)
    }
    
    private func fileURL(for key: String) throws -> URL {
        // URL'lerdeki ge√ßersiz karakterleri i≈üle
        let safeKey = key.replacingOccurrences(of: "/", with: "_")
                         .replacingOccurrences(of: ":", with: "_")
                         .replacingOccurrences(of: "?", with: "_")
                         .replacingOccurrences(of: "&", with: "_")
                         .replacingOccurrences(of: "=", with: "_")
                         .replacingOccurrences(of: "%", with: "_")
        
        let cacheURL = try diskCacheDirectoryURL()
        return cacheURL.appendingPathComponent(safeKey)
    }
    
    private func loadImageFromDiskCache(for key: String) -> UIImage? {
        do {
            let fileURL = try fileURL(for: key)
            
            // Dosya yoksa nil d√∂nd√ºr
            guard fileManager.fileExists(atPath: fileURL.path) else {
                return nil
            }
            
            // Dosya ge√ßerliliƒüini kontrol et
            let attributes = try fileManager.attributesOfItem(atPath: fileURL.path)
            if let modificationDate = attributes[.modificationDate] as? Date {
                let expirationDate = modificationDate.addingTimeInterval(diskCacheTimeoutDays * 24 * 60 * 60)
                if Date() > expirationDate {
                    // Dosya s√ºresi dolmu≈ü, sil
                    try fileManager.removeItem(at: fileURL)
                    return nil
                }
            }
            
            // Dosyayƒ± y√ºkle
            let data = try Data(contentsOf: fileURL)
            return UIImage(data: data)
        } catch {
            print("Disk √∂nbelleƒüinden g√∂rsel y√ºklenirken hata: \(error)")
            return nil
        }
    }
    
    private func saveImageToDiskCache(_ image: UIImage, for key: String) {
        downloadQueue.async { [weak self] in
            guard let self = self else { return }
            
            do {
                guard let data = image.jpegData(compressionQuality: 0.8) else { return }
                let fileURL = try self.fileURL(for: key)
                try data.write(to: fileURL)
            } catch {
                print("G√∂rsel disk √∂nbelleƒüine kaydedilirken hata: \(error)")
            }
        }
    }
    
    private func downloadImage(from url: URL, cacheKey: String, completion: @escaping (UIImage?) -> Void) {
        downloadQueue.async {
            let task = URLSession.shared.dataTask(with: url) { data, response, error in
                // HTTP yanƒ±tƒ±nƒ± kontrol et
                guard let httpResponse = response as? HTTPURLResponse,
                      (200...299).contains(httpResponse.statusCode),
                      let data = data,
                      error == nil,
                      let image = UIImage(data: data) else {
                    DispatchQueue.main.async {
                        completion(nil)
                    }
                    return
                }
                
                DispatchQueue.main.async {
                    completion(image)
                }
            }
            task.resume()
        }
    }
    
    private func cleanExpiredDiskCache() {
        downloadQueue.async { [weak self] in
            guard let self = self else { return }
            
            do {
                let cacheURL = try self.diskCacheDirectoryURL()
                let resourceKeys: [URLResourceKey] = [.contentModificationDateKey, .totalFileAllocatedSizeKey]
                let contents = try self.fileManager.contentsOfDirectory(
                    at: cacheURL,
                    includingPropertiesForKeys: resourceKeys,
                    options: .skipsHiddenFiles
                )
                
                // Son deƒüi≈üim tarihine g√∂re dosyalarƒ± filtrele
                let expirationDate = Date().addingTimeInterval(-self.diskCacheTimeoutDays * 24 * 60 * 60)
                for fileURL in contents {
                    let resourceValues = try fileURL.resourceValues(forKeys: Set(resourceKeys))
                    if let modificationDate = resourceValues.contentModificationDate,
                       modificationDate < expirationDate {
                        try self.fileManager.removeItem(at: fileURL)
                    }
                }
            } catch {
                print("Disk √∂nbelleƒüi temizlenirken hata: \(error)")
            }
        }
    }
}

// MARK: - Uzantƒ±lar

extension UIImageView {
    /// Bir g√∂rseli URL'den y√ºkler ve √∂nbellekte saklar
    /// - Parameters:
    ///   - urlString: G√∂rsel URL'si
    ///   - placeholder: Y√ºkleme sƒ±rasƒ±nda g√∂sterilecek g√∂rsel
    func loadImage(from urlString: String, placeholder: UIImage? = nil) {
        self.image = placeholder
        
        ImageCache.shared.loadImage(from: urlString) { [weak self] image in
            guard let self = self else { return }
            
            DispatchQueue.main.async {
                UIView.transition(with: self, duration: 0.3, options: .transitionCrossDissolve) {
                    self.image = image ?? placeholder
                }
            }
        }
    }
}

extension Image {
    /// SwiftUI i√ßin bir g√∂rseli URL'den y√ºklemek ve √∂nbellekte saklamak i√ßin uzantƒ±
    static func cachedImage(for urlString: String) -> Image {
        if let cachedImage = ImageCache.shared.getImage(forKey: urlString) {
            return Image(uiImage: cachedImage)
        }
        return Image(systemName: "photo")
    }
} 